<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.setRemoteDescription - add/remove remote tracks</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
  'use strict';

  // The following helper functions are called from RTCPeerConnection-helper.js:
  //   exchangeOffer
  //   exchangeOfferAnswer
  //   Resolver

  // These tests are concerned with the observable consequences of processing
  // the addition or removal of remote tracks, including events firing and the
  // states of RTCPeerConnection, MediaStream and MediaStreamTrack.

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    caller.addTrack(localStream.getTracks()[0]);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.track.id, localStream.getTracks()[0].id,
                      'Local and remote track IDs match.');
        assert_equals(e.streams.length, 0, 'No remote stream created.');
        ontrackResolver.resolve();
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOffer(caller, callee);
    await ontrackResolver.promise;
  }, 'addTrack() with a track and no stream makes ontrack fire with a track and no stream.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.track.id, localStream.getTracks()[0].id,
                      'Local and remote track IDs match.');
        assert_equals(e.streams.length, 1, 'Created a single remote stream.');
        assert_equals(e.streams[0].id, localStream.id,
                      'Local and remote stream IDs match.');
        assert_array_equals(e.streams[0].getTracks(), [e.track],
                            'The remote stream contains the remote track.');
        ontrackResolver.resolve();
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOffer(caller, callee);
    await ontrackResolver.promise;
  }, 'addTrack() with a track and a stream makes ontrack fire with a track and a stream.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      eventSequence += 'ontrack;';
      ontrackResolver.resolve();
    };
    await exchangeOffer(caller, callee);
    eventSequence += 'setRemoteDescription;';
    await ontrackResolver.promise;
    assert_equals(eventSequence, 'ontrack;setRemoteDescription;');
  }, 'ontrack fires before setRemoteDescription resolves.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStreams = [
      await navigator.mediaDevices.getUserMedia({audio:true}),
      await navigator.mediaDevices.getUserMedia({audio:true}),
    ];
    caller.addTrack(localStreams[0].getTracks()[0], localStreams[0]);
    caller.addTrack(localStreams[1].getTracks()[0], localStreams[0]);
    let ontrackEventsFired = 0;
    const ontrackEventResolvers = [ new Resolver(), new Resolver() ];
    callee.ontrack = e => {
      if (ontrackEventsFired < ontrackEventResolvers.length)
        ontrackEventResolvers[ontrackEventsFired].resolve(e);
      ++ontrackEventsFired;
    };
    await exchangeOffer(caller, callee);
    let firstTrackEvent = await ontrackEventResolvers[0].promise;
    assert_equals(firstTrackEvent.track.id,
                  localStreams[0].getTracks()[0].id,
                  'First ontrack\'s track ID matches first local track.');
    assert_equals(firstTrackEvent.streams.length, 1,
                  'First ontrack fires with a single stream.');
    assert_equals(firstTrackEvent.streams[0].id,
                  localStreams[0].id,
                  'First ontrack\'s stream ID matches local stream.');
    let secondTrackEvent = await ontrackEventResolvers[1].promise;
    assert_equals(secondTrackEvent.track.id,
                  localStreams[1].getTracks()[0].id,
                  'Second ontrack\'s track ID matches second local track.');
    assert_equals(secondTrackEvent.streams.length, 1,
                  'Second ontrack fires with a single stream.');
    assert_equals(secondTrackEvent.streams[0].id,
                  localStreams[0].id,
                  'Second ontrack\'s stream ID matches local stream.');
    assert_array_equals(firstTrackEvent.streams, secondTrackEvent.streams,
                        'ontrack was fired with the same streams both times.');
    assert_array_equals(firstTrackEvent.streams[0].getTracks(),
                        [firstTrackEvent.track, secondTrackEvent.track],
                        'The remote stream == [first track, second track].');
    assert_equals(ontrackEventsFired, 2, 'Unexpected number of track events.');
  }, 'addTrack() with two tracks and one stream makes ontrack fire twice with the tracks and shared stream.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    const localStreams = [
      await navigator.mediaDevices.getUserMedia({audio:true}),
      await navigator.mediaDevices.getUserMedia({audio:true}),
    ];
    caller.addTrack(localStreams[0].getTracks()[0], localStreams[0]);
    const remoteStreams = [];
    callee.ontrack = e => {
      if (!remoteStreams.includes(e.streams[0]))
        remoteStreams.push(e.streams[0]);
    };
    await exchangeOfferAnswer(caller, callee);
    assert_equals(remoteStreams.length, 1, 'One remote stream created.');
    assert_equals(remoteStreams[0].getTracks()[0].id,
                  localStreams[0].getTracks()[0].id,
                  'First local and remote tracks have the same ID.');
    const onaddtrackResolver = new Resolver();
    remoteStreams[0].onaddtrack = e => {
      try {
        assert_equals(e.track.id,
                      localStreams[1].getTracks()[0].id,
                      'Second local and remote tracks have the same ID.');
        onaddtrackResolver.resolve();
      } catch (ex) {
        onaddtrackResolver.reject(ex);
      }
    };
    caller.addTrack(localStreams[1].getTracks()[0], localStreams[0]);
    await exchangeOffer(caller, callee);
    await onaddtrackResolver.promise;
    assert_equals(remoteStreams.length, 1, 'Still a single remote stream.');
  }, 'addTrack() for an existing stream makes stream.onaddtrack fire.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    const localStreams = [
      await navigator.mediaDevices.getUserMedia({audio:true}),
      await navigator.mediaDevices.getUserMedia({audio:true}),
    ];
    caller.addTrack(localStreams[0].getTracks()[0], localStreams[0]);
    const remoteStreams = [];
    callee.ontrack = e => {
      if (!remoteStreams.includes(e.streams[0]))
        remoteStreams.push(e.streams[0]);
    };
    await exchangeOfferAnswer(caller, callee);
    assert_equals(remoteStreams.length, 1, 'One remote stream created.');
    const onaddtrackResolver = new Resolver();
    remoteStreams[0].onaddtrack = e => {
      eventSequence += 'stream.onaddtrack;';
      onaddtrackResolver.resolve();
    };
    caller.addTrack(localStreams[1].getTracks()[0], localStreams[0]);
    await exchangeOffer(caller, callee);
    eventSequence += 'setRemoteDescription;';
    await onaddtrackResolver.promise;
    assert_equals(remoteStreams.length, 1, 'Still a single remote stream.');
    assert_equals(eventSequence, 'stream.onaddtrack;setRemoteDescription;');
  }, 'stream.onaddtrack fires before setRemoteDescription resolves.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStreams = [
      await navigator.mediaDevices.getUserMedia({audio:true}),
      await navigator.mediaDevices.getUserMedia({audio:true})
    ];
    caller.addTrack(localStreams[0].getTracks()[0],
                    localStreams[0], localStreams[1]);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.track.id, localStreams[0].getTracks()[0].id,
                      'Local and remote track IDs match.');
        assert_equals(e.streams.length, 2, 'Two remote stream created.');
        assert_array_equals(e.streams[0].getTracks(), [e.track],
                            'First remote stream == [remote track].');
        assert_array_equals(e.streams[1].getTracks(), [e.track],
                            'Second remote stream == [remote track].');
        assert_equals(e.streams[0].id, localStreams[0].id,
                      'First local and remote stream IDs match.');
        assert_equals(e.streams[1].id, localStreams[1].id,
                      'Second local and remote stream IDs match.');
        ontrackResolver.resolve();
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOffer(caller, callee);
    await ontrackResolver.promise;
  }, 'addTrack() with a track and two streams makes ontrack fire with a track and two streams.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    caller.addTrack(localStream.getTracks()[0]);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_array_equals(callee.getReceivers(), [e.receiver],
                            'getReceivers() == [e.receiver].');
        ontrackResolver.resolve();
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOffer(caller, callee);
    await ontrackResolver.promise;
  }, 'ontrack\'s receiver matches getReceivers().');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = caller.addTrack(localStream.getTracks()[0]);
    const ontrackResolver = new Resolver();
    callee.ontrack = () => { ontrackResolver.resolve(); };
    await exchangeOfferAnswer(caller, callee);
    await ontrackResolver.promise;
    assert_equals(callee.getReceivers().length, 1, 'One receiver created.');
    caller.removeTrack(sender);
    await exchangeOffer(caller, callee);
    assert_equals(callee.getReceivers().length, 1, 'Receiver not removed.');
  }, 'removeTrack() does not remove the receiver.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.streams.length, 1);
        ontrackResolver.resolve(e.streams[0]);
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOfferAnswer(caller, callee);
    const remoteStream = await ontrackResolver.promise;
    const remoteTrack = remoteStream.getTracks()[0];
    const onremovetrackResolver = new Resolver();
    remoteStream.onremovetrack = e => {
      try {
        assert_equals(e.track, remoteTrack);
        assert_equals(remoteStream.getTracks().length, 0,
                      'Remote stream emptied of tracks.');
        onremovetrackResolver.resolve();
      } catch (ex) {
        onremovetrackResolver.reject(ex);
      }
    };
    caller.removeTrack(sender);
    await exchangeOffer(caller, callee);
    await onremovetrackResolver.promise;
  }, 'removeTrack() makes stream.onremovetrack fire and the track to be removed from the stream.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.streams.length, 1);
        ontrackResolver.resolve(e.streams[0]);
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOfferAnswer(caller, callee);
    const remoteStream = await ontrackResolver.promise;
    const remoteTrack = remoteStream.getTracks()[0];
    const onremovetrackResolver = new Resolver();
    remoteStream.onremovetrack = e => {
      eventSequence += 'stream.onremovetrack;';
      onremovetrackResolver.resolve();
    };
    caller.removeTrack(sender);
    await exchangeOffer(caller, callee);
    eventSequence += 'setRemoteDescription;';
    await onremovetrackResolver.promise;
    assert_equals(eventSequence, 'stream.onremovetrack;setRemoteDescription;');
  }, 'stream.onremovetrack fires before setRemoteDescription resolves.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.streams.length, 1);
        ontrackResolver.resolve(e.streams[0]);
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOfferAnswer(caller, callee);
    const remoteStream = await ontrackResolver.promise;
    const remoteTrack = remoteStream.getTracks()[0];
    const onmuteResolver = new Resolver();
    remoteTrack.onmute = () => {
      try {
        assert_true(remoteTrack.muted);
        onmuteResolver.resolve();
      } catch (ex) {
        onmuteResolver.reject(ex);
      }
    };
    caller.removeTrack(sender);
    await exchangeOffer(caller, callee);
    await onmuteResolver.promise;
  }, 'removeTrack() makes track.onmute fire and the track to be muted.');

  promise_test(async t => {
    const caller = new RTCPeerConnection();
    const callee = new RTCPeerConnection();
    let eventSequence = '';
    const localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = caller.addTrack(localStream.getTracks()[0], localStream);
    const ontrackResolver = new Resolver();
    callee.ontrack = e => {
      try {
        assert_equals(e.streams.length, 1);
        ontrackResolver.resolve(e.streams[0]);
      } catch (ex) {
        ontrackResolver.reject(ex);
      }
    };
    await exchangeOfferAnswer(caller, callee);
    const remoteStream = await ontrackResolver.promise;
    const remoteTrack = remoteStream.getTracks()[0];
    const onmuteResolver = new Resolver();
    remoteTrack.onmute = () => {
      eventSequence += 'track.onmute;';
      onmuteResolver.resolve();
    };
    caller.removeTrack(sender);
    await exchangeOffer(caller, callee);
    eventSequence += 'setRemoteDescription;';
    await onmuteResolver.promise;
    assert_equals(eventSequence, 'track.onmute;setRemoteDescription;');
  }, 'track.onmute fires before setRemoteDescription resolves.');

  promise_test(async t => {
    const pc = new RTCPeerConnection();
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    const sender = pc.addTrack(stream.getTracks()[0]);
    pc.removeTrack(sender);
    pc.removeTrack(sender);
  }, 'removeTrack() twice is safe.');
</script>
